* 关于powerpc的MMU管理
** 关于e500的MMU
*** 关于tlb中的tlb0/tlb1的区别
    #+BEGIN_VERSE
    1. tlb0映射的方式采用的是页表式映射，TLB0中一共有256个entry，每个4Kbyte，只能映射1Mbyte的空间。
       即使已经给某进程的虚拟空间分配了实际的物理页面，也会经常产生TLB miss 异常。
       尤其是操作系统中进程调度频繁，每次调度进程都要无效掉整个TLB0，产生很多的TLB miss。
       这样应该会比较影响系统的性能,注意:L1MMU中的TLB表项为L2MMU中的表项子集，其更新又硬件完成。
    2. tlb1映射的方式采用的是段式映射，用TLB1 进行虚拟地址的段式映射，
       采用段式映射可以直接使用硬件提供的TLB1查找表，可以一次映射较大区域
       （可达256MB），从而减少缺页故障次数，其虚实地址转换效率高。
       TLB1 则设计用于映射大页（比如 16MB, 256MB ...），支持可变页大小，
       E500v1 可支持 9 个页大小（最大 256MB），E500v2 则支持 11 个页大小（最大 4GB）。
       使用时可将某项设为永驻 TLB1 （通过置 Invalidation Protection 位，简写为 IPROT 位），
       不会被动态替换，实现为全相联，共 16 项，可将其理解为用于映射 16 个段的可编程固定映射机制。
    总结相见网页：[[http://hi.baidu.com/comcat/item/5a34fd2afef1b887ae48f582][e500MMU介绍]]
    #+END_VERSE
** 关于e600/e603/e300的MMU
   1.相同点
   有块映射/页映射/段映射。
   2.不同点
   a. e600中有大块映射模式，且支持36位VA地址寻址，
      但是要设置HID0[XAEN]=1,大块映射(大于256M)时需要设置
      HID0[XBSEN]=1,此种方式必须要同时设置HID0[XAEN]=1,
      HID0[XBSEN]=1,此处起作用的是BAT[0-3] BAT[4-7]
      (若HID0[HIGH_BAT_EN]使能的话。);
   b. HID0[HIGH_BAT_EN]=1此设置将表示BAT[4-7]
      可用.
* 关于powerpc汇编指令
** 寄存器
   略
** 常见寄存器的作用及使用
   记住关键点:
   1.当使用取指令或者逻辑运算时
    Rs作为目的寄存器，Ra作为源寄存器
   2.当作为存指令时
    Rs作为源寄存器，Ra作为目的操作符
   3.跳转寄存器LR
   4.PC指针作为下一条指令的执行入口。
    
* 关于powerpc中断与异常
** e600的中断与异常
*** 常见的异常类型说明及产生原因
**** Machine Check Interrupt (0x00200)
**** DSI Interrupt (0x00300)
    #+BEGIN_VERSE
    1. 在进行TLB不命中的操作，例如加载tlb/换出tlb/或者其他cache操作导致的缺页异常。
    2. 任何直接存取到段映射（SR[T]=1）的操作。
    3. 在cache属性为禁止cache/写穿cache的情况下，执行lwarx/stwcx.(即操作了MMU不能写的地址)将导致DSI异常。 
    4. 在执行数据断点时，将导致DSI异常触发(在MSR[IP]=1的情况下)。
    #+END_VERSE
**** ISI Interrupt (0x00400)
    #+BEGIN_VERSE
    1. EA不能进行RA的转化时。
    2. 在不能执行的段进行取指令操作(SR[N]=1)
    3. 在cache属性为guard并且MSR[IR]=1时,对进行取指令操作。
    4. 在内存可变保护区间进行取指令操作。 
    #+END_VERSE
**** External Interrupt (0x00500)
    #+BEGIN_VERSE
    1. 前提
    在设置MSR[EE]=1,并且int信号有效期间
    2. 触发方式
     a. 软件自触发
        可以通过设置ICTRL[CIRQ]=1,并且在MSR[EE]=1,触发了一个外部中断事件。
     b. 硬件触发
        接入的外部激励信号触发,此处略.
    #+END_VERSE
**** Alignment Exterrupt(0x00600)
    #+BEGIN_VERSE
    1. 触发条件
      a. 浮点数的存取不是字节性对齐的操作。
      b. lmw, stmw, lwarx, or stwcx.的多字节存取指令不是字节性对齐操作。
      c. 在cache页属性为写穿或者cache禁止时，使用dcbz将cache中的数据清零
      d. 在data cache禁止或者锁定时，尝试使用dcbz将cache进行清零操作。
      e. 在MSR[LE]=1时，尝试做多字节访问或者字符串的访问。
    #+END_VERSE
**** Program Interrupt (0x00700)
    #+BEGIN_VERSE
    1. 触发条件
      a. 在进行mtspr或者mfspr(Rc设置为1时）
      b. 
    #+END_VERSE
** e300的中断与异常
*** 
* 关于调试应用的快速定位
** 确保函数调用过程图
   1.使用tt 任务ID，查看相互调用关系图。
   2.使用ti 任务ID，查看任务本身状况。
     a.使用d命令查看任务的PC代码段，出错大多由于free/空间未分配访问导致。
     b.使用d命令查看任务的sp即栈空间情况。   
* 关于linux中嵌入结构体元素
** 原因是通过结构体在另一个结构体的位置将原有的元素
   组成一个连续的内存单元,即形成类似于linux的继承。
** 关于linux中的结构体中的结构体指针,实际上是
   将其他的元素包含到里面直接注册来使用。
* 关于linux的C类型转换
** 不得将const类型的数据转换为非const类型的数据
   否则将丢失const的属性。
** 不得将volaitle类型的数据转换为非volatile的数据
   否则将丢失volatile的特性。
** 不得将具有register类型的数据转换为非register的
   数据,否则将丢失register的特性。
** 
* 关于e500的pci的inbound/outbound空间配置
** PEXITARn
   表示的是local bus的地址空间。
   TEA的地址表示的是36bit的高4位的地址，TA的地址
   表示的是32位地址的bit0~bit19。
** PEXIWBARn
   表示的是PCIe的地址空间
   WBEA表示的是PCIe的43-32的扩展地址域，WBA的地址
   表示的是PCIe的地址[31~12]。
* 关于调试BSP中的手段
** 在内存中定一个内存标记
   1。实现
   void dbg_mem_set(int line) 
   {
       if(*(unsigned short*)0xf00000 == 常量)
       {
            *(unsigned short*)0xa000000= line;
       }
   }
   
   定位代码中,dbg_mem_set(__LINE__);
** 使用led进行点灯操作
** 使用仿真器，进行单步调试定位。
** 打印信息
** 使用__LINE__，信息在内存中打桩
* 关于DOS中的for详解
** tokens指定以分割符为单位的多少个
   x,y,m-n - 指每行的哪一个符号被传递到每个迭代 
的 for 本身。这会导致额外变量名称的分配。m-n 
格式为一个范围。通过 nth 符号指定 mth。如果 
符号字符串中的最后一个字符星号， 
那么额外的变量将在最后一个符号解析之后 
分配并接受行的保留文本。
** delims指定分隔符
** skip指的是文件开始忽略的行数
** 注意语法中要使用括号作为标记
** FOR /R [[drive:]path] %variable IN (set) DO command [command-parameters]  
*** 此命令会搜索指定路径及所有子目录中与set相符合的所有文件，注意是指定路径及所有子目录。 
　　1、set中的文件名如果含有通配符(？或*)，则列举/R参数指定的目录及其下面的所用子目录中与set相符合的所有文件，无相符文件的目录则不列举。 
　　2、如果set中为具体文件名，不含通配符，则枚举该目录树（即列举该目录及其下面的所有子目录）(并在后面加上具体的文件名)，而不管set中的指定文件是否存在。
* 关于硬件设计的网页
** CMOSedu.com
* 关于硬件的问题分析定位
** 确认大致的问题来源，分析时序以及FPGA的一些问题
* 为何结构体中的元素域的第一个元素是首地址呢
** 原因是这样便于定位结构体在内存中的位置，而且便于写
   出一些优秀灵活的代码。
* 为何代码在引用其它代码的时候要使用函数原型
** 原因是文件直接的编译是分块进行的，当文件调用另外一个
   文件中的函数时，如果没有函数原型的话，编译器并不知道
   传递到另外一个函数的参数是不能确认的，所以在引用其它
   文件中的函数时，必须声明原型；若不声明的话，编译器会
   假定一个int型的函数形参供调用者调用，但是这样会导致
   若函数定义的时候不是int型，而是long long型的话，将
   导致参数调用失败。
* 调试桥设备的时候问题定位
** 首先分析其工作机理
** 确认问题的来源
** 进一步缩小范围
** 查看可能引起的问题原因
* 调试Phy
** 确认Phy地址
** 确认MII接口是否能够进行正常的Phy寄存器读写
** 确认Phy的状态，工作模式。
** 确认MII接口到Phy侧的数据是否OK,Phy侧到变压器侧是否OK
* 芯片资料的查看
** 关注其Vdd/Vss/GND，其IO管脚
** 注意查看其通信的机理
** 注意观察其时序的要求
** 注意确认管脚的状态是否为三态/双向管脚
** 特别注意芯片中的errata
* vxWorks中的任务
** 在任务创建的时候，使用taskSpawn时，将导致任务调度队列进行一次调度
* 关于vxworks6.8的问题
* 关于设计模式
** 使用指针来保存当前的对象，并使用该内存对应的另外的对象模型
　　进行对象可操作性。 
* 关于采样定理中的硬件实现
** 主要是硬件数字电路中的各种触发器来完成这个动作的。 
* 运算放大器
** 一是响应频率，一是反馈
* 硬件准备
** 查看硬件原理图
** 查看硬件的复位过程，包括基本的供电要求，上电时序
** 查看硬件工作的时序
* 关于软件架构设计
** 针对C语言的特性，由于顶层设计时考虑包含底层所有的指针元素
** 结构体首元素的地址等价于结构体的地址
** 首先学习别人的框架设计，然后再自己写，模仿好的软件设计，以及编码风格
* 关于硬件调试
** 若简单的读写不正常，调整硬件时序
** 若概率性问题，则要查CPLD/FPGA/软件本身的问题,软件字节性对齐,package
** 硬件问题的话，想办法调整硬件的信号质量/信号完整性
* 时序的采样
** 都是逻辑电路中的二极管组成的或门与与门的并发条件，同时条件都满足的情况下，
   才能进行时序满足
* 汇编
** .type symbol,expression标识函数在elf中的调试符号有效
** .size symbol,type(#define	FUNC_END(func)		.size	FUNC(func), . - FUNC(func)) 
   标识在调试文件信息保留符号表
* 软件开发强人
** 技术强人
*** 学习新的软件开发方法
*** 构建新的软件建模方式
*** 学习unix的编程思维
*** 学习国外的开发方式
*** 研究多个不同的操作系统
*** 研究多个不同的开发平台
* 关于ata命令集
** sector
   #+BEGIN_VERSE
   1. LBA指的是在逻辑扇区不够的情况下，
      其能够表示的block的个数
   #+END_VERSE
** 读写操作
   #+BEGIN_VERSE
   1. 在读写操作后面一般会有一个buffer的填充的寄存器，发送
      时为发送数据缓冲区的首地址，接收时为接收数据缓冲区的首地址
   2. 注意在什么时候将该操作进行打断，以及何种情况下导致不稳定的。
   #+END_VERSE
* e500 core与e600 core之间的区别
** e500 core不带L2Cache,其双核之间通过L2共享cache实现
** e600 core自带一个L2Cache
** ppc的cache实质操作在cacheAlib.s文件中
* e500MMU
** 实质文件位于mmue500Alib.s
* GNU编译链接过程中可操作
** 删除静态链接文件中的一个模块文件
   <1> arppc.exe /？
** 详情查看帮助文件
* 如何修改vxworks系统中的文件
** 直接将系统中的文件添加到工程文件中，在编译即可
** 将系统中的静态库文件中删除相应的模块文件，然后修改系统文件，再编译即可。
* vim
** vim打开二进制文件
   <1> 进入底行模式,输入:%!xxd,即可
* powerpc的pci与pcie
** pci其配置都是依赖于硬件配置或者cpld的
** pci作为agent mode的时候，配置inbound空间的时候
   实际上是没有配置pci的地址域的，这是因为配置了以后
   意义也不大哈，且host端应该会配置哈
